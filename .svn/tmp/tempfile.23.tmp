;---------------------------  
; Reading any netcdf file
;---------------------------  
FUNCTION nc_read, file_name, var_name, ncdf_db, BOXZOOM = boxzoom, TIME_1 = time_1,  TIME_2 =  time_2, ALL_DATA = all_data, NO_MEAN = no_mean

; arguments = file_name, varname
; ncdf_db=<location>:<path> or just <path>
; mot clef = iodir time_1 time_2

@common
@com_eg
<<<<<<< .mine

=======
  
>>>>>>> .r90
; inits
   IF debug_w THEN print, '   '
   IF debug_w THEN print, '   ENTER nc_read...'

   IF NOT keyword_set(TIME_1) THEN time_1 =  1
   IF NOT keyword_set(TIME_2) THEN time_2 =  time_1
<<<<<<< .mine
   IF debug_w THEN print, '    key_yreverse : ', key_yreverse  
;
; decide which subdomain of data to read
;
=======
>>>>>>> .r90

<<<<<<< .mine
   IF debug_w THEN print, '    keyword_set(ALL_DATA) : ', keyword_set(ALL_DATA) 
=======
>>>>>>> .r90

; decide which subdomain of data to read
   IF debug_w THEN print, '     keyword_set(ALL_DATA) : ', keyword_set(ALL_DATA)
   IF keyword_set(ALL_DATA) THEN BEGIN
<<<<<<< .mine
      print, '    Reading whole domain'
      firstx = 0
      firsty = 0
      firstz = 0
      nx = jpi
      ny = jpj
      nz = jpk
      lastx = jpi-1
      lasty = jpj-1
      lastz = jpk-1
      IF debug_w THEN print, '       set key_yreverse to 0'
      key_yreverse = 0
;Rajout MK
;Trouver une meilleure place
      ixminmesh = 0
      iyminmesh = 0
      ixmaxmesh = jpi-1
      iymaxmesh = jpj-1
;Fin rajout
   ENDIF ELSE BEGIN
      grille,mask,glam,gphi,gdep,nx,ny,nz,firstx,firsty,firstz,lastx,lasty,lastz
      mask = 1
   ENDELSE
=======
      tout = 1
   ENDIF ELSE tout = 0
   CASE vert_type OF
      'z' : zindex = 0
      'level' : zindex = 1
      ELSE: zindex = 0
   ENDCASE
>>>>>>> .r90

; local directory
   IF strpos(ncdf_db, ':') GE 1 THEN directory = (strsplit(ncdf_db, ':', /EXTRACT))[1] $
    ELSE directory = ncdf_db

; Find the variable's attribute
   ncdf_getatt, directory+file_name, var_name, add_offset = add_offset, scale_factor = scale_factor, $
    missing_value = missing_value, units = units, calendar = calendar, long_name = long_name

; By default units for the Z axis are meters
   IF n_elements(gdept) GT 1 THEN BEGIN
      IF name_level NE '-' THEN $
       ncdf_getatt, directory+file_name, name_level, units = units_depth ELSE units_depth = 'm'
   ENDIF ELSE units_depth = ''

; Check consistency between time_2 computed from param in cmdline and the max number
; of time steps found in the file.
   jpt_max = find_jptmax(file_name, IODIRECTORY = directory)
   IF time_2-time_1+1 GT jpt_max AND jpt_max NE -1 THEN time_2 = time_1+jpt_max-1

; Read the data with a call to read_ncdf
   IF debug_w THEN print, '     '
   IF debug_w THEN print, '     Reading raw data from ',  file_name

   lec_data = read_ncdf(var_name, time_1-1, time_2-1, BOXZOOM = boxzoom, FILENAME = directory+file_name, $
                        /TIMESTEP, /ADDSCL_BEFORE, TOUT = tout, /NOSTRUCT, /CONT_NOFILL, GRID = vargrid, $
                        ZINVAR = zinvar, ZINDEX = zindex)
   field_dim = (size(lec_data))[0]
   IF field_dim LE 0 THEN stop,  '  Something wrong happened in read_ncdf '

   IF debug_w THEN print, '     '
   IF debug_w THEN print,  '    boxzoom=', boxzoom
   IF debug_w THEN print,  '    firstxt,firstyt,firstzt=', firstxt, firstyt, firstzt
   IF debug_w THEN print,  '    lastxt,lastyt,lastzt=', firstxt, firstyt, firstzt   
   IF debug_w THEN print,  '    zinvar=', zinvar
   IF debug_w THEN print, '     ixmindta,iymindta,izmindta  =', ixmindta,iymindta,izmindta
   IF debug_w THEN print, '     ixminmesh,iyminmesh=', ixminmesh,iyminmesh
   IF debug_w THEN print, '     ixmaxmesh,iymaxmesh=', ixmaxmesh,iymaxmesh 
   IF debug_w THEN print, '     izminmesh,izmaxmesh=', izminmesh,izmaxmesh 
   IF debug_w THEN print, '     jpt=', jpt
   IF debug_w THEN print, '     key_shift=', key_shift
   IF debug_w THEN print, '     key_yreverse=',key_yreverse 
   IF debug_w THEN print, '     '
   
; Average data along vertical if needed and update some features
; needed for plt (data_direc, name_suff)
   name_suff = ''
   data_direc = ''
   update_data, TAB = lec_data, VNAME = var_name, BOXZOOM = boxzoom, ZUNITS = units_depth, $
    ZINVAR = zinvar, SUFFIX = name_suff, D_DIREC = data_direc, $
    TIME_1 = time_1, TIME_2 =  time_2, NO_MEAN = no_mean
   field_dim = (size(lec_data))[0]

<<<<<<< .mine
               varidl = ncdf_varid(cdfid, name_level)
               ; make sure name_level is in hPa
               ncdf_attget, cdfid, varidl, 'units', val_unit
               IF string(val_unit) NE 'hPa' AND string(val_unit) NE 'millibar' AND string(val_unit) NE 'mbar' THEN BEGIN 
                  print, '  vertical levels coordinate not obvious'
                  print, '  ... using <levels> ...'
                  varidl = ncdf_varid(cdfid, 'levels')
               ENDIF 
               ncdf_varget, cdfid, varidl, gdept 
               gdepw = gdept
               e3t = shift(gdept, 1)-gdept
               e3t[0] = e3t[1]
               e3w = e3t
               jpk = nb_level
               tmask = reform((reform(tmask(*, *), jpi*jpj)#replicate(1, jpk)), jpi, jpj, jpk)
            ENDIF 
            @read_ncdf_varget
            lec_data = res
            data_direc = 'xyzt'

;           vertical average ?
            IF vert_switch ge 1  AND NOT keyword_set(no_mean) THEN BEGIN 
               old_boite = [lon1, lon2, lat1, lat2, prof1, prof2]
               print, '      Average in vertical domain ', vert_type, vert_mean
               IF mesh_type EQ 'atm' THEN BEGIN
                  CASE atmos_msk OF 
                     0: print, '          [take all points] ' ; take all points
                     1: BEGIN
                        ; take ocean points only
                        idx = where(tmask EQ 0)
                        lec_data(idx) = 1.e20
                        print, '          [take ocean points only] '
                     END
                     2: BEGIN
                        ; take land points only
                        idx = where(tmask GT 0)
                        lec_data(idx) = 1.e20
                        print, '          [take land points only] '
                     END
                  ENDCASE 
                  CASE vert_type OF
                     'z': BEGIN ; levels
                        
                        IF vert_mean[0] EQ vert_mean[1] THEN BEGIN
                           name_suff = ' at '+strtrim(string(long(gdept(vert_mean(0)))), 2)+' hPa'
                        ENDIF ELSE BEGIN
                           zmean = grossemoyenne(lec_data, 'z', boite = vert_mean)
                           name_suff = ' averaged in '+vert_type+'['+strtrim(string(vert_mean(0)), 2)+','+strtrim(string(vert_mean(1)), 2)+']'
                        ENDELSE 
                     END 
                     ELSE: BEGIN ; levels
                        IF vert_mean[0] EQ vert_mean[1] THEN BEGIN
                           zmean = lec_data(*, *, vert_mean[0])
                           name_suff = ' at '+vert_type+' '+strtrim(string(long(vert_mean(0))), 2)+' ['+strtrim(string(gdept(vert_mean(0))), 2)+' hPa]'
                        ENDIF ELSE BEGIN
                           zmean = moyenne(lec_data, 'z', boite = vert_mean, /zindex)
                           name_suff = ' averaged in '+vert_type+'['+strtrim(string(long(vert_mean(0))), 2)+','+strtrim(string(long(vert_mean(1))), 2)+']'
                        ENDELSE 
                     END 
                  ENDCASE 
;                  tmask = reform(tmask(*, *, 0), jpi, jpj)
               ENDIF ELSE BEGIN
                  ; ocean = always mask
                  ; idx = where(tmask EQ 0)
                  ; lec_data(idx) = 1.e20
                  CASE vert_type OF
                     'z': BEGIN
                        IF vert_mean[0] EQ vert_mean[1] THEN BEGIN
                           zmean = lec_data
                           name_suff = ' at '+strtrim(string(long(gdept(vert_mean(0))+.1)), 2)+' m'
                        ENDIF ELSE BEGIN
                           zmean = grossemoyenne(lec_data, 'z', boite = vert_mean)
                           name_suff = ' averaged in '+vert_type+'['+strtrim(string(long(vert_mean(0))), 2)+','+strtrim(string(long(vert_mean(1))), 2)+']'
                        ENDELSE 
                     END 
                     ELSE: BEGIN
                        IF vert_mean[0] EQ vert_mean[1] THEN BEGIN
                           zmean = lec_data
                           name_suff = ' at '+strtrim(string(long(gdept(vert_mean(0))+.1)), 2)+' m'
                        ENDIF ELSE BEGIN
                           zmean = moyenne(lec_data, 'z', boite = vert_mean, /zindex, NAN =1.e20)
                           name_suff = ' averaged in '+vert_type+'['+strtrim(string(long(vert_mean(0))), 2)+','+strtrim(string(long(vert_mean(1))), 2)+']'
                        ENDELSE 
                     END 
                  ENDCASE 
               ENDELSE 
               lec_data = zmean
               domdef, old_boite
               field_dim = field_dim - 1
               data_direc = 'xyt'
               nzt = 1
               firstz = 0
               lastz = 0
            ENDIF 
         ENDELSE 
      END 
     ;; erreur si dim > 4
      ELSE: BEGIN
         err_mess =  '  *** nc_read : ERROR dimension > 4'
         lec_data = -1.0
      END
   ENDCASE 

;  get valmask (might need valmask = float(string(valmask))

   valmask = 1.e20
   FOR i = 0, varinq.natts-1 DO BEGIN
      att_txt = ncdf_attname(cdfid, varid, i)
      IF att_txt EQ 'missing_value' OR att_txt EQ 'mask value' OR att_txt EQ '_FillValue' THEN ncdf_attget, cdfid, varid, att_txt, valmask
   ENDFOR 

; ensure valmask is positive

   IF valmask LT 0 THEN BEGIN
      print, '      *** Warning valmask is negative - changing sign: ', valmask
      idx_t = where (lec_data EQ valmask)
      IF idx_t(0) NE -1 THEN lec_data(idx_t) = -valmask
      valmask = -valmask
   ENDIF

; set valmask to 1.e20

; scaling ?
   FOR i = 0, varinq.natts-1 DO BEGIN
      att_txt = ncdf_attname(cdfid, varid, i)
      IF debug_w THEN print, '     att_txt = ', att_txt
      IF att_txt EQ 'scale_factor' THEN BEGIN
         ncdf_attget, cdfid, varid, att_txt, valscale
         IF valscale NE 1. THEN BEGIN 
            print, '     Field scaled by ',valscale
            idx_t = where (lec_data GT valmask/10)
            new_fld = float(lec_data)*float(valscale)
            IF idx_t(0) NE -1 THEN new_fld(idx_t) = valmask
            lec_data = new_fld
         ENDIF 
      ENDIF 
   ENDFOR 

   idx_t=0  ; free memory
   new_fld = 0

; Attribut du champ

=======
; Field attributes
>>>>>>> .r90
   field = {name: '', data: lec_data, legend: '', units: '', origin: '', dim: 0, direc: data_direc}
   field.name = var_name
   field.origin = directory+file_name
   field.legend = long_name+name_suff
   field.units = units
   field.dim = field_dim 

; get valmask (might need valmask = float(string(valmask))

<<<<<<< .mine


; if pseudo 3d mask, read mask file and set masked points to valmask

; to do

=======
; valmask = 1.e20
   IF size(missing_value,  /TYPE) EQ 4 OR size(missing_value,  /TYPE) EQ 5 THEN BEGIN
      valmask = missing_value
>>>>>>> .r90
<<<<<<< .mine
=======
; ensure valmask is positive
      IF valmask LT 0 THEN BEGIN
         print, '      *** Warning valmask is negative - changing sign: ', valmask
         idx_t = where (field.data EQ valmask)
         IF idx_t(0) NE -1 THEN field.data(idx_t) = -valmask
         valmask = -valmask
         idx_t=0                ; free memory
      ENDIF
   ENDIF

>>>>>>> .r90
; min/max

   chardim = ' - dim = '
   FOR i = 1, (size(field.data))[0] DO BEGIN 
      chardim = chardim+string((size(field.data))[i], format = '(I5)')
   ENDFOR  

   index_test = (where (field.data LE valmask/10.))
   IF index_test(0) NE -1 THEN BEGIN 
      minf = min(field.data(where (field.data NE valmask)))
      maxf = max(field.data(where (field.data NE valmask)))
   ENDIF ELSE BEGIN 
      minf =  min(field.data)
      maxf =  max(field.data)
   ENDELSE 

   print, '      = ',field.legend, '    [min/max = ',minf , maxf,'  ', field.units,' - masked values = ',valmask, chardim, ']'

   IF debug_w THEN print,  '  ...EXIT nc_read'
   IF debug_w THEN print,  '  '
   
   return, field

END 
